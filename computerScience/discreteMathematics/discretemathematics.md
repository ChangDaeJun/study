## 집합(set)

### 수학과 컴퓨터에서의 집합(Set in Math and Computer)
| 구분            | 수학(Math)            | 컴퓨터(computer)      |
|---------------|---------------------|--------------------|
| 표기(write)     | N = {1, 2, 3, ...}  | Boolean = {0, 1}   |
| 연산자(operator) | 덧셈(+), 뺄셈(-), 곱셈(*) | AND, OR, NOT |

### JAVA 데이터형의 집합 표현(Represent data type in Java as a set)
| 타입(Type) | 표현                                          |
|---------|---------------------------------------------|
| Boolean | {0, 1}                                      |
| Int     | {–2,147,483,648, ...., 0, 1, 2, ... 2,147,483,647} |
| Char    | {0, 1, 2 , ... , 2^16}                      |
| String  | Char^n의 멱집합(power set of char ^ n)          |
| Float   | Boolean(1bit) X (8bit) X (23bit)            |
| Double  | Boolean(1bit) X (11bit) X (52bit)           |


### 비트열 연산 (bitwise)
* 컴퓨터에서는 집합의 부분집합을 비트열로 표현할 수 있다.
* 예를 들어 U = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}의 짝수 부분집합 A는 다음과 같이 표현된다.
* A = 0101010101 = {2, 4, 6, 8, 10}
* 비트열로 부분집합을 표현할 경우 장점은 차집합, 교집합, 여집합 등을 컴퓨터 연산자(AND, OR, XOR)으로 구할 수 있다.
* 예
```
When U = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, A = {2, 4, 6, 8, 10}, B = {2, 3, 5, 10}
A is 0101010101, B is 0110100001.

A union B (OR)
0101010101
0110100001
----------
0111110101

A Intersection B(AND)
0101010101
0110100001
----------
0100000001

(A Union B) - (A Intersection B) (XOR)
0101010101
0110100001
----------
0011110100

```
* 해당 디렉토리의 Bitwise.java 을 참고. https://github.com/ChangDaeJun/study/blob/main/computerScience/discreteMathematics/Bitwise.java

## 함수(Function)

### 컴퓨터와 함수(Function in computer)
* 프로그래밍에서 메서드는 함수와 매우 유사하다.
```java
int function(int num){}
```
* 위 메서드는 정의역이 int이고, 치역이 int 인 함수와 동일하다.
* 만약, 내가 제작한 메서드의 정의역이 {0, 2, 4, 6, 8}이고, 치역이 {0, 1, 2, 3, ...}이라면, 이를 객체로 나타낼 필요가 있어 보인다.
```java

public Range fuction(Domain d){
    return d / 2;
}

class Range{
    private int num;
    public Range(int num){
        if(num < 0) throw Exception;
        this.num = num;
    }
}

class Domain{
    private int num;
    public Domain(int num){
        if(num % 2 != 0 || num < 0) throw Exception;
        this.num = num;
    }
}
```
* (개인적 추측) 함수의 측면에서 자바의 메서드는 반드시 하나의 객체만을 받아, 하나의 객체만을 리턴해야 한다.

## 알고리즘

### 알고리즘이란?
* 알-콰리즈(Al-Khowarizmi)의 이름이 변형된 것으로, 연산 뿐만 아니라 일반적인 문제를 해결하는 명확한 절차를 의미한다.

### 탐색 알고리즘
* 선형 탐색(linear search)
```
    배열 : {a0, a1, a2, ..., ai, ..., an}
    
    1. 반복(i 범위: 0 ~ n)
        1-1. 만약 i번째 원소가 일치하면, i번째 원소 반환 후 종료
        
    2. 0을 반환 후 종료(여기까지 도달했음은 일치하는 원소가 없음을 의미)
```
* 이진 탐색(binary search)
```
    배열 : {a0, a1, a2, ..., ai, ..., an}
    
    1. 배열을 오름차순으로 정렬
    
    2. 왼쪽값 = 0, 오른쪽값 = n으로 정하기
    
    3. 반복(왼쪽값 == 오른쪽값이 될때까지)
        3-1. 중간값을 구함.(왼쪽값 + 오른쪽값) / 2
        3-2. 중간값 위치 수와 찾고자 하는 값을 비교
            3-2-크다: 찾는 값보다 크면, 왼쪽값을 3-1의 중간값으로 교체
            3-2-작다: 찾는 값보다 작으면, 오른쪽값을 3-2의 중간값으로 교체
            3-2-같다: 현재 위치를 반환
    
    4. 0을 반환(여기까지 도달했음은 일치하는 원소가 없음을 의미)
```

### 정렬
* 버블정렬
* 삽입정렬
* 퀵정렬
* 힙정렬
* 머지정렬
* 선택정렬

### 그리디 알고리즘(greedy algorithm)
* 계산원 알고리즘(cashier's algorithm)
* 25센트, 10센트, 5센트, 1센트 동전을 거스름돈으로 줄때, 액면가가 큰 순서대로 줄 수 있는 최대의 개수를 줄때 동전을 최소로 사용한다.
* 일반화하면, 동전 c1, c2, ..., cn을 거스름돈으로 줄 때 액면가가 가장 큰 동전부터 순서대로 남은 거스름돈을 초과하지 않고 최대한 줄 때 동전을 최소로 사용한다.
> 주어진 알고리즘을 p(n) (n는 거스름돈)라 하고, p1, p2, ..., pn을 각각 거스름돈으로 사용한 동전c1, c2, ..., cn의 개수라 하자. </br>
> 적당한 알고리즘 a(n)이 존재하여, p(n) > a(n)이라고 가정하자. a1, a2, ..., an 역시 동일하게 정의한다. </br>
> 먼저 a1과 p1을 비교하면, p(n)의 정의에 의해 p1 >= a1 이다. </br>
> 왜냐하면, p(n)은 c1의 동전을 최대한 사용하기 때문이다. </br>
> 하지만, p(n) > a(n)일 수도 없다. 만약 그렇다면, 적어도 1개 이상의 c1 동전을 c2, c3, ..., cn의 동전으로 표현해야 하는데, 이는 c1의 동전 개수보다 항상 크다. 따라서 p(n) = a(n)이다. </br>
> 일반성을 잃지 않고, 1까지 실행했을 때, 임의의 i에 대해 pi == ai이다. </br>
> 즉, p(n) > a(n)이라는 가정의 모순을 통해, 주어진 알고리즘은 항상 최소의 동전을 사용한다.</br>

### 정지 문제(halting problem)
* 프로그램과 프로그램의 입력을 입력으로 받아 해당 프로그램이 무한루프에 빠지는지 또는 정지하는지 알 수 있는 알고리즘은 존재하지 않는다.
> 주어진 문제를 해결하는 알고리즘을 H(P, I)라고 하자.(P는 프로그램, I는 p의 변수)</br>
> 그러면, 프로그램 P에 대해서 H(P,P)역시 고려할 수 있다. </br>
> 이제 H(P, P)의 결과와 반대를 작동하는 프로그램 K(P)을 생각하자. 즉 P가 무한으로 동작하면, K(p)는 정지하고, P가 정지한다면, K(p)는 무한으로 동작한다.</br>
> 만약 H(K, K)가 무한으로 동작한다면, K(K)는 정지하게 되며 이는 모순이다.
> 반대로, H(K, K)가 정지한다면, K(K)는 무한으로 동작하게 되며 이는 모순이다.
> 따라서 H와 같은 프로그램은 존재할 수 없다.

## 정수론

### 모듈로(modulo)
* m이 a-b를 나누면, a=b(mod m)이라고 한다. 이때, a와 b를 모듈로 m 합동이라고 한다.
* a=b(mod m), c=d(mod m) 이면, a + c = b + d(mod m)이다.

### 밑수 전환(base Conversion)
* 정수 12345을 밑수 8로 전환하는 방법은 다음과 같다.
> 12345 = 8 * 1543 + 1 </br>
> 1543 = 8 * 192 + 7 </br>
> 182 = 8 * 24 + 0 </br>
> 24 = 8 * 3 + 0 </br>
> 3 = 8 * 0 + 3 </br>
> 
> 따라서, 12345(10) = 30071(8)
* 의사코드로 나타내면, 다음과 같다.
```
    1. 정수 n과 밑 b를 매개변수로 받는다.
    
    2. 전개결과를 담을 스택 S를 만든다.
    
    3. cur = n으로 담는다.
    
    4. 반복(cur = 0 일 때 까지)
        4-1. cur % b 값을 스택 S에 담는다.
        4-2. cur 값을 cur / b로 변경한다.
        
    5. 스택에서 순서대로 수를 뽑아 a1a2a3...an(b)을 만든다.
```
* 2, 4, 8, 16 ... 진 사이의 전환은 더 쉬운 편이다.
> 11 1111 1000 0001 (2) 는 16진수로 전환 시 4개씩 끊어 3, 16, 8, 1(16)이다.

### 정수의 덧셈
* 비트가 n개인 두 이진수 정수를 덧셈하기 위해서는 각 비트 자리를 더하고, 받아올림을 해야 한다. 즉 O(n)만큼의 비트 덧셈이 진행된다.

### 정수의 곱셈
* 일반적인 곱셈에서는 각 자리별로 곱한 뒤, 모든 결과를 더하게 된다. 즉, 비트 n의 이진수를 곱하기 위해서는 비트 n의 이진수를 n번 더하게 됨으로 총 n^2의 비트 뎃셈이 필요하다.
* 하지만 어떤 알고리즘은 n^1.585 만큼의 비트 연산을 사용한다.


## 참고자료(Reference)
* Rosen의 이산수학 8th Edition(맥그로힐에듀케이션코리아, 2019)